                                                      操作系统之作业管理之死锁

概念

死锁是指两个或两个以上的进程在执行中，因为对于资源的争夺或者由于互相通信有问题的原因。陷入了一种在没有外力介入的情况下一直互相遏制到地老天荒的情况。
就如同前面的文章中举的哲学家的例子，所有的哲学家都不愿意放下手中的筷子给别人用，所以大家只能一起饿死。就像两头倔牛撞在了一起一样，谁也不肯退后一步。

死锁的产生

进程之间互相竞争资源：举一个例子，A进程已经控制了传真机，B进程已经控制了打印机，A进程等待打印机的资源被释放，B进程等待传真机的资源被释放。都在等待释
放，结果谁也等不到，就耗死了。本质还是因为资源不够，要是再多一个传真机打印机就好了。
进度调度顺序不当：因为程序的进程调度不当所造成的运行错误，同样会造成上面的错误。

产生死锁的四个必要条件

互斥条件：进程对资源的使用是排他性的使用，在某一个进程使用资源时，只能由他一个进程来使用。其他进程只能等待这个进程使用完毕。
请求保持条件：在本身占据了至少一个资源后，又提出了新的资源请求，在新的资源请求未果的情况下，进入阻塞状态。使得他本身所占据的资源也不能被释放，有点贪
得无厌的感觉。
不可剥夺条件:进程的资源在为运行结束之前不得被释放，只有进程自身才能释放。
环路等待条件：就是形成了一个完美的环路等待，比如说1等2，2等3，3等4，4等1，这种令人无语的环路。

死锁的处理

预防死锁的方法：只要破坏了上述产生死锁的四个条件其中的一个，死锁也就无法形成了。
破坏请求保持条件：在所有进程运行之前，命令所有进程申请完他们所需要的所有资源。
破坏不可剥夺条件：当一个进程请求新的资源失败时，他就会被释放掉所有他现在占有的资源。
破坏环路等待条件：申请必须一个一个来，使得申请环路不再出现。

银行家算法：客户每次贷款的金额是有限的，并且每次都会声明贷款的金额，银行家在手中的资金足够的情况下，都应该给客户发放贷款，客户在使用贷款后必须及时归
还。换算到程序里就是已分配资源表，所需资源表，可分配资源表，还需分配资源表这四个表。和银行的经理一样，自己去算。








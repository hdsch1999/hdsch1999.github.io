                                                    操作系统之linux的存储管理

Buddy内存管理算法
交换空间（swap）是磁盘的一个空间。

linux物理内存满时，会把一些内存交换至swap空间。

swap空间是在初始化的时候就要配置的，就类似于我们的d盘，e盘一样。
此算法是基于计算机处理二进制的优势之上的，使得这个算法具有极高的效率。
这个算法主要是为了解决内存外碎片的问题的。页内碎片我们前面已经提到了，就是已经被分配出去的内存空间大于我们存储那个进程所需的空间，这样就会导致我们用来放
这个进程的空间有所盈余，而这个盈余如果不能再次被利用的话，这个剩余的空间就叫内部碎片。
外部碎片是指还没有被分配出去但是他的大小与申请分配内存的进程不符合，因此无法分配给申请内存空间的新内存。这就是页外碎片，有没有被分配，是一个重要的判断条
件。
这个算法的核心就是让内存分配和相邻内存合并，并且让这一切快速进行，这一切也是依赖于计算机处理二进制的优势。
buddy内存管理算法的内存分配原则就是，对于进程申请的内存大小，我们将其向上取整为2的幂大小。比如，进程申请70k，我们分配给他128k，进程申请129k，我们就给他
分配256k。说白了就是二的次方。
伙伴系统：这里的伙伴，指的是一片连续的内存，他的伙伴就是另一片大小相当的连续内存。这个算法会创建一系列空闲块链表，每一种都是2的幂。比如：1，2，4，8，16。
举个例子：我们分配一个100k的内存，那么我们向上取2的幂。开始寻找128k的空闲链表，没有，找256k的，没有。找512k的，没有，找1M的，有了。那么我们就将1m的空闲
内存块分配给他，就下来我们将1m内存块分为两个512k的，看512k是能够装内存的最小内存块。不是就继续往下分，一直到能装他的最小内存块为止。也就是128k的内存块，
至于其它的内存块，就放在各自规格的内存空闲链表下。说白了就是给进城找内存块放他，要是放的内存块比他本身大很多，就将内存块分解，直到内存块的大小为存放进程
所申请的内存的最小内存块为止。
这个算法的回收内存方法：就是判断刚才分配出去的内存在不在空闲链表上，在的话就看看他的伙伴在不在空闲链表中，在的话就合并，一直重复，一直到我们所分配的最高
的空闲块为止。
这个算法的问题是：将内存外碎片转移成了内存的内碎片。比如进程申请一个100k的内存，我们给他分配了一个128k的内存，这多出来的28k内存就成了内存的内碎片。

linux交换空间


